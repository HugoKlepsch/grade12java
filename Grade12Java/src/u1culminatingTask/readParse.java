/*
		 Title: tupleHack.java
		 Programmer: hugo
		 Date of creation: Apr 2, 2015
		 Description: 
*/

package u1culminatingTask;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * @author hugo
 *
 */
public class readParse {
	private int[] marksArray;
	private int count = 0;

	public readParse(int[] marksArray) {
		this.marksArray = marksArray;
	}

	public int[] readMarks(int numStudents, String pathIn) throws IOException {
		BufferedReader fileIn = new BufferedReader(new FileReader(pathIn)); // open the file again...
		String line; // string to hole the data from each readline()
		count = 0; // the number of students in the file (I don't use numStudents because I am assuming that the
					// first half of the program doesn't really exist. If it were in a real school the marks would
					// be generated by the teachers, and then computed by the program. I therefore can't use
					// numStudents.
		do { // do while because don't need to init variables and one less conditional check #efficiency

			line = fileIn.readLine(); // read a line from the file
			if (line != null) { // sanity check to make sure it's not the end of the file
				int value = Integer.parseInt(line); // turn the line into an integer and hold it in a variable
				marksArray[count] = value; // put the variable into the array
				count += 1; // only increment the count if we actually have a student mark, null does not count.
			}
		} while (line != null); // fileIn.readline() returns null on the end of a file, so it reads until it reaches the
								// null.
								// Realistically I could have assumed that the number of elements is the same as the
								// numStudents variable. I wanted to find a way to read a "n" line file, so I
								// implemented that.

		fileIn.close(); // close the file reading object to properly finish using the filesystem
		return marksArray;
	}

	public int getCount() {
		return count;
	}

}
